{"version":3,"sources":["Components/Search/Search.js","Components/Search/Welcome.js","Components/Face/Faceblobs.js","Components/Face/Facepredicts.js","Components/Face/Face.js","Components/Nav/Nav.js","Components/User/Signin.js","Components/User/Register.js","Components/Profile/Profilecards.js","Components/Profile/Profile.js","App.js","serviceWorker.js","index.js"],"names":["Search","geturl","onDetect","getState","pasteClipboard","className","id","type","placeholder","size","onChange","onPaste","onClick","Welcome","userProfile","name","Faceblobs","faceSelect","blobURL","map","face","i","faceblobs","key","src","alt","width","raceOptions","Facepredicts","currPredictions","pred","predClass","gender","age","race","Face","this","props","setSendBlob","document","querySelectorAll","forEach","el","classList","remove","querySelector","add","crossOrigin","onLoad","canvas","getElementById","ctx","getContext","imgObj","blobFile","blobCount","naturalWidth","height","naturalHeight","sx","bleft","sy","btop","sWidth","bright","sHeight","bbot","drawImage","toBlob","blob","push","length","boxname","boxStyle","top","left","bottom","right","style","React","Component","Nav","onRouteChange","Signin","updateUser","server","htmlFor","value","email","password","fetch","method","headers","body","JSON","stringify","then","resp","json","data","profile","console","log","alert","onSubmitSignIn","Register","userid","onSubmitRegister","Cards","image","onClickProfileImg","imgurl","imgid","oriurl","href","Profile","userImages","initialState","input","route","userPredictions","isNewPredict","isImgClipboard","blobClipboard","App","state","getPrediction","clipboard","a","form","FormData","append","response","setState","images","predictions","concat","newRoute","revokeStateURL","blob2imgArr","blobs","URL","createObjectURL","url","revokeObjectURL","event","target","pasteEvent","callback","returnCb","clipboardData","undefined","items","indexOf","getAsFile","getBlobClipboard","removeAttribute","predid","msg","catch","err","sendBlobs","filter","predict","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","registration","unregister","error","message"],"mappings":"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","file":"static/js/main.6fb744e9.chunk.js","sourcesContent":["import React from 'react';\r\nimport './Search.css'\r\n\r\nconst Search = ({geturl, getState, onDetect, pasteClipboard}) => {\r\n    return (\r\n        <div className='search'>\r\n            <input id=\"search-input\" type='text' placeholder='Enter URL' size='60' onChange={geturl} onPaste={pasteClipboard}/>\r\n            <button className='btn' onClick={onDetect}>Detect</button>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default Search;","import React from 'react';\r\n\r\nconst Welcome = ({userProfile}) => {\r\n    return (\r\n        <div className=\"welcome\">\r\n            <h1>Welcome <span className=\"username\">{userProfile.name}</span>!</h1>\r\n            <h4>Provide a face to detect. Paste an image URL or take a screenshot, paste in the input below, and hit detect!</h4>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default Welcome;","import React from 'react';\r\nimport './Faceblobs.css';\r\n\r\nconst Faceblobs = ({faceSelect, blobURL}) => {\r\n    return (\r\n        <div className='faceblobs-div'>\r\n            {\r\n                blobURL.map((face,i) => {\r\n                    const faceblobs = `faceblobs-image fb${i}`\r\n                    return <div key={i}>\r\n                        <img className={faceblobs} src={face} alt='face' width='40px' onClick={() => faceSelect(i)}/>\r\n                    </div>\r\n                })\r\n            }\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default Faceblobs;","import React from 'react';\r\nimport './Facepredicts.css'\r\n\r\nconst raceOptions = [\r\n    \"native hawaiian or pacific islander\",\r\n    \"black or african american\",\r\n    \"american indian or alaska native\",\r\n    \"middle eastern or north african\",\r\n    \"asian\",\r\n    \"white\",\r\n    \"hispanic, latino, or spanish origin\"\r\n]\r\n\r\nconst Facepredicts = ({currPredictions}) => {\r\n    return (\r\n        <div className='face-predicts'>\r\n            {currPredictions.map((pred,i) => {\r\n                const predClass = `preds preds${i}`;\r\n                return (\r\n                    <div key={i} className={predClass}>\r\n                        <div>\r\n                            <p className='preds-label'>Gender:</p>\r\n                            <p className='preds-output'>{pred.gender ? \"masculine\" : \"feminine\"}</p>\r\n                        </div>\r\n                        <div>\r\n                            <p className='preds-label'>Age:</p>\r\n                            <p className='preds-output'>{pred.age}</p>\r\n                        </div>\r\n                        <div>\r\n                            <p className='preds-label'>Cultural:</p>\r\n                            <p className='preds-output'>{raceOptions[pred.race]}</p>\r\n                        </div>\r\n                    </div>\r\n                )\r\n            })}\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default Facepredicts;","import React from 'react';\r\nimport './Face.css';\r\nimport Faceblobs from './Faceblobs';\r\nimport Facepredicts from './Facepredicts';\r\n\r\nclass Face extends React.Component{\r\n    render(){\r\n        const {currPredictions, blobURL, setSendBlob} = this.props;\r\n        const faceSelect = (id) => {     // showing prediction data, show border for face blobs, and highlight bounding box on image\r\n            // showing prediction data\r\n            const unSelectPred = document.querySelectorAll(`.preds`);       // can have multiple images\r\n            unSelectPred.forEach(el => el.classList.remove(\"highlight\"))    // remove class \"highlight\" from all of them\r\n            const selectPred = document.querySelector(`.preds${id}`);       // get the id of the face being clicked, then select the corresponding prediction element\r\n            selectPred.classList.add(\"highlight\");                          // show the prediction data\r\n            // show border\r\n            const unSelectFace = document.querySelectorAll(\".faceblobs-image\")\r\n            unSelectFace.forEach(el => el.classList.remove(\"faceblobs-selected\"))\r\n            const selectFace = document.querySelector(`.fb${id}`);       \r\n            selectFace.classList.add(\"faceblobs-selected\");              \r\n            // highlight bounding box\r\n            const unSelectBox = document.querySelectorAll(\".box\")\r\n            unSelectBox.forEach(el => el.classList.remove(\"box-select\"))\r\n            const selectBox = document.querySelector(`.box${id}`);       \r\n            selectBox.classList.add(\"box-select\"); \r\n        }\r\n\r\n        const drawFaceBlobs = () => {\r\n            const canvas = document.getElementById(\"myCanvas\");\r\n            const ctx = canvas.getContext('2d');\r\n            const imgObj = document.querySelector(\".face-image\");\r\n            let blobFile = [];    // where blobs will be appended to\r\n            let blobCount = 0;     // keep track of completed blobs (bcz it's asynchronous)\r\n            // grab original width and height of image (no matter how it scales in browser, croping with ctx.drawImage still uses the original props of image)\r\n            const width = imgObj.naturalWidth;\r\n            const height = imgObj.naturalHeight;\r\n            currPredictions.forEach(pred => {\r\n                // calculating crop area around detected faces\r\n                const sx = width * pred.bleft / 100;\r\n                const sy = height * pred.btop / 100;\r\n                const sWidth = (width * (100 - pred.bright))/100 - sx;\r\n                const sHeight = (height * (100 - pred.bbot))/100 - sy;\r\n                const targetImageSize = 80;     // output face blob resolution\r\n                canvas.width = canvas.height = targetImageSize;\r\n                ctx.drawImage(imgObj, sx, sy, sWidth, sHeight, 0, 0, targetImageSize, targetImageSize);\r\n                canvas.toBlob(blob => {         // .toBlob doesn't return immediate value, but the blob will show in a callback once it finish loading (async)\r\n                    blobFile.push(blob);        // store each blob in an array\r\n                    blobCount++;\r\n                    if(blobCount === currPredictions.length){\r\n                        setSendBlob(blobFile) }   // when all the blobs have been collected\r\n                }, 'image/jpeg', 0.95);\r\n            })\r\n        }\r\n\r\n        return (\r\n            <div className='face hidden'>\r\n                <div className='face-whole'>\r\n                    <div className=\"face-bboxes\">\r\n                        <img className=\"face-image\" alt='face' src='' crossOrigin=\"anonymous\" onLoad={drawFaceBlobs}/>\r\n                        {\r\n                            currPredictions.map((pred,i) => {\r\n                                const boxname = `box box${i} btn`;\r\n                                let boxStyle = {top: pred.btop+'%', left: pred.bleft+'%', bottom: pred.bbot+'%', right: pred.bright+'%'}\r\n                                return(\r\n                                    <div key={i} className={boxname} style={boxStyle} onClick={() => faceSelect(i)}></div>\r\n                                )\r\n                            })\r\n                        }\r\n                    </div>\r\n                </div>\r\n                <div className=\"face-info\">\r\n                    <h5>Face detected: {currPredictions.length}</h5>\r\n                    <div className=\"face-predictions\">\r\n                        <Faceblobs faceSelect={faceSelect} blobURL={blobURL}/>\r\n                        <Facepredicts currPredictions={currPredictions}/>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\nexport default Face;","import React from 'react';\r\n\r\nconst Nav = ({onRouteChange}) => {\r\n    return (\r\n        <div className='nav hidden'>\r\n            <p className='btn signout' onClick={() => onRouteChange('signin')}>Sign Out</p>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default Nav;","import React from 'react';\r\nimport './Signin.css';\r\n\r\nconst onSubmitSignIn = (onRouteChange, updateUser, server) => {\r\n    const email = document.getElementById(\"signin-email\").value;\r\n    const password = document.getElementById(\"signin-pass\").value;\r\n    fetch(server+'signin', {\r\n        method: 'post',\r\n        headers: {'Content-Type': 'application/json'},\r\n        body: JSON.stringify({ email, password })\r\n    })\r\n    .then(resp => resp.json())\r\n    .then(data => {\r\n        if (data.profile){       // means if the data has a profile property, differentiating from the error message\r\n            console.log(data);\r\n            updateUser(data);\r\n            onRouteChange('content');\r\n            document.querySelector('.nav').classList.remove('hidden');  // if successfully signin, show the signout nav\r\n        } else {\r\n            alert(data);\r\n        }\r\n    })\r\n}\r\n\r\nconst Signin = ({onRouteChange, updateUser, server}) => {\r\n    return (\r\n        <div className='Signin'>\r\n            <h1>Sign In</h1>\r\n            <label htmlFor=\"signin-email\">Email</label>\r\n            <input type=\"email\" name=\"signin-email\" id=\"signin-email\"/>\r\n            <label htmlFor=\"signin-pass\">Password</label>\r\n            <input type=\"password\" name=\"signin-pass\" id=\"signin-pass\"/>\r\n            <input className=\"submit\" type=\"submit\" value=\"Sign In\" onClick={() => onSubmitSignIn(onRouteChange, updateUser, server)}/>\r\n            <input className=\"btn-register\" type=\"submit\" value=\"Register\" onClick={() => onRouteChange('register')}/>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default Signin;","import React from 'react';\r\nimport './Register.css';\r\n\r\nconst onSubmitRegister = (onRouteChange, updateUser, server) => {\r\n    const name = document.getElementById(\"register-name\").value\r\n    const email = document.getElementById(\"register-email\").value;\r\n    const password = document.getElementById(\"register-pass\").value;\r\n    fetch(server+'register', {\r\n        method: 'post',\r\n        headers: {'Content-Type': 'application/json'},\r\n        body: JSON.stringify({ name, email, password })\r\n    })\r\n    .then(resp => resp.json())\r\n    .then(data => {\r\n        if (data.profile.userid){\r\n            updateUser(data);\r\n            onRouteChange('content');\r\n            document.querySelector('.nav').classList.remove('hidden');  // if successfully registered, show the signout nav\r\n        } else {\r\n            alert(data);\r\n        }\r\n    })\r\n  }\r\n\r\nconst Register = ({onRouteChange, updateUser, server}) => {\r\n    return (\r\n        <div className='register'>\r\n            <div className=\"back-arrow\">\r\n                <img className=\"btn\" src=\"https://img.icons8.com/nolan/64/arrow-pointing-left.png\"\r\n                width=\"30px\" height=\"30px\" alt=\"back\" onClick={()=>onRouteChange(\"signin\")}/>\r\n                <p>Back</p>\r\n            </div>\r\n            <div className='content-register'>\r\n                <h1>Register</h1>\r\n                <label htmlFor=\"register-name\">Name</label>\r\n                <input type=\"text\" name=\"name\" id=\"register-name\" placeholder=\"make up a name\"/>\r\n                <label htmlFor=\"register-email\">Email</label>\r\n                <input type=\"email\" name=\"email-address\" id=\"register-email\" placeholder=\"make up any email\"/>\r\n                <label htmlFor=\"register-pass\">Password</label>\r\n                <input type=\"password\" name=\"pass\" id=\"register-pass\" placeholder=\"make up any password\"/>\r\n                <input className=\"btn-register\" type=\"submit\" value=\"Register\" onClick={() => onSubmitRegister(onRouteChange, updateUser, server)}/>\r\n            </div>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default Register;","import React from 'react';\r\nimport './Profilecards.css';\r\n\r\n\r\nconst Cards = ({image, onClickProfileImg, server}) => {\r\n    return (\r\n        <div className='card-div'>\r\n            <img src={server+image.imgurl} className='card-image'\r\n             alt='people' width='150' height='100' onClick={() => onClickProfileImg(image.imgid)}/>\r\n            <div className='card-text'>\r\n                {\r\n                    image.oriurl === 'user_data'\r\n                    ? <p>user data</p>\r\n                    : <a className='card-link' href={image.oriurl}>src</a>\r\n                }\r\n                <p>[{image.face}]</p>\r\n            </div>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default Cards;","import React from 'react';\r\nimport './Profile.css';\r\nimport Profilecards from './Profilecards';\r\n\r\nconst Profile = ({userImages, onClickProfileImg, server}) => {\r\n    return (\r\n        <div className='profile-div'>\r\n            <h3 className='profile-title'>History <span className='profile-title-face'>[face detected]</span></h3>\r\n            <div className='profile-img'>\r\n                {userImages.map((image, i) => {\r\n                    return <Profilecards key={i} image={image} onClickProfileImg={onClickProfileImg} server={server}/>\r\n                })}\r\n            </div>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default Profile;","import React from 'react';\nimport './App.css';\nimport Search from './Components/Search/Search';\nimport Welcome from './Components/Search/Welcome';\nimport Face from './Components/Face/Face';\nimport Nav from './Components/Nav/Nav';\nimport Signin from './Components/User/Signin';\nimport Register from './Components/User/Register';\nimport Profile from './Components/Profile/Profile';\n\n\nconst initialState = {\n  input: '',              // stores the value of the main input\n  route: 'signin',        // handles parts of app that shows: signin, register, and main-content\n  userImages: [],\n  userPredictions: [],\n  userProfile: '',\n  currPredictions: [],    // prediction data of the selected image (either from new predict or history image)\n  blobURL: [],            // contains objectURL converted from canvas crops\n  isNewPredict: false,    // if true, then the user predicts a new image, false means the user clicks on a history image\n  isImgClipboard: false,  // source of data from copied clipboard or from an image url\n  blobClipboard: ''       // temporarily stores the blob data of a clipboard image to preview in Face component\n}\n\nconst server = 'https://face-demographic-detection.herokuapp.com/';\n// const server = 'http://localhost:5000/';\n\nclass App extends React.Component{\n  state = { ...initialState } // using spread operator prevents mutating the initialState\n\n  render(){\n    const geturl = (event) => { this.setState({ input: event.target.value}) }\n    const getState = () => { console.log(this.state) }    // for debugging purpose, create a button in Search.js with onClick of this func\n\n    const getPrediction = async (clipboard) => {\n      if(clipboard){    // if data comes from a clipboard image, sends clipboard image and wait for the prediction results\n        const form = new FormData();\n        form.append(\"imgBlob\", this.state.blobClipboard, \"clipboardImage\");\n        form.append(\"userid\", this.state.userProfile.userid);\n        try {\n          const response = await fetch(server+'predictclipboard', { method: 'post', body: form })\n          return await response.json()\n        } catch (error) {\n          return error          \n        }\n      } else {      // if data comes from a URL, sends image URL and wait for prediction results\n        this.setState({isNewPredict: true});\n        try {\n          const response = await fetch(server+'predict', {\n            method: 'post',\n            headers: {\"Content-Type\": \"application/json\"},\n            body: JSON.stringify({\"imgUrl\": this.state.input, \"userid\": this.state.userProfile.userid})\n          })\n          return await response.json()\n        } catch (error) {\n          return error\n        }\n      }\n    }\n\n    // when user clicks on detect button\n    const onDetect = async () => {\n      const response = await getPrediction(this.state.isImgClipboard);\n      if (response.images){   // if the response contains prediction data\n        document.querySelector('.face').classList.remove('hidden');\n        document.querySelector(\".face-image\").src = server+response.images[0].imgurl;   // set to static url in server where the image was downloaded\n        this.setState({     // appends the new prediction data to previous history\n          currPredictions: response.predictions,\n          userImages: this.state.userImages.concat(response.images),\n          userPredictions: this.state.userPredictions.concat(response.predictions)\n        });\n        this.setState({isImgClipboard: false});   // reset to false again\n      } else {\n        alert(response);\n      }\n      document.getElementById(\"search-input\").value = '';   // clear the input url\n    }\n\n    // triggers when user clicks a history image\n    const onClickProfileImg = (imgid) => {\n      document.querySelector('.face').classList.remove('hidden');\n      this.setState({isNewPredict: false})\n      const imgObj = document.querySelector(\".face-image\");\n      // find the selected image using imgid\n      const images = this.state.userImages.filter(image => image.imgid === imgid);\n      imgObj.src = server+images[0].imgurl;\n      // grab predictions related to the imgid and map the data to state.predict, and local url to state.blobUrl\n      const predictions = this.state.userPredictions.filter(predict => predict.imgid === imgid);\n      this.setState({currPredictions: predictions});\n    }\n\n    // handles what content is shown: signin (home), register or main-content\n    const onRouteChange = (newRoute) => {\n      if(newRoute==='signin'){                                    // if returning to signin view (means user is signing out)\n        revokeStateURL()                                          // revoke prev objectURL in state\n        document.querySelector('.nav').classList.add('hidden');   // hide the signout nav\n        this.setState(initialState);                              // reset to initialState\n      }\n      this.setState({route: newRoute});\n    }\n\n    // updates the user data\n    const updateUser = (data) => { this.setState({\n      userImages: data.images,\n      userPredictions: data.predictions,\n      userProfile: data.profile\n    }) }\n\n    // sends cropped face blobs using FormData\n    const sendBlobs = (blobFile) => {\n      console.log(\"sending blobs..\");\n      const form = new FormData();\n      for (let i=0; i<blobFile.length; i++){    // loop through all predictions\n        const id = this.state.currPredictions[i].predid;\n        form.append(\"image\", blobFile[i], id)   // id will be the originalname went sent to server\n      }\n      fetch(server+'blobs', { method: 'post', body: form })\n      .then(resp => resp.json())\n      .then(msg => console.log(msg))\n      .catch(err => console.log(err))\n    }\n\n    // triggers when all blobs are drawn from canvas draw operation in Face.js\n    const setSendBlob = (blobFile) => {\n      revokeStateURL();\n      this.setState({ blobURL: blob2imgArr(blobFile) });    // stores objectURL of face blobs\n      if(this.state.isNewPredict){sendBlobs(blobFile)}      // if it's a new prediction, send the new blobs to server\n    }\n\n    //  convert new blobs into objectURL and returns the URL\n    const blob2imgArr = (blobs) => blobs.map(blob => URL.createObjectURL(blob))\n\n    // revoke previous objectURL\n    const revokeStateURL = () => { this.state.blobURL.forEach(url => URL.revokeObjectURL(url)) }\n\n    // check if clipboard contains images, if yes, return it as blob\n    const getBlobClipboard = (pasteEvent, callback) => {\n      const returnCb = (data) => { if(typeof(callback) === \"function\") callback(data) }   // make sure the callback is a function, if yes return data\n      if(pasteEvent.clipboardData === false){ returnCb(undefined) };      // if no data is in clipboard, return callback(undefined)\n      const items = pasteEvent.clipboardData.items;             // get clipboard data\n      if(items === undefined){ returnCb(undefined) };           // if no items are present, return callback(undefined)\n      // items is an array containing data of the clipboard, in case of droping objects may contain multiple data\n      for (let i=0; i<items.length; i++) {\n        if(items[i].type.indexOf(\"image\") === -1) continue;     // indexOf returns -1 if it doesn't find a match, \"continue\" skips that loop\n        const blob = items[i].getAsFile();                      // get image on clipboard as blob\n        returnCb(blob);                                         // blob data is available in callback\n      }\n    }\n    \n    // when the user paste something to the input element, previews if its an image\n    const pasteClipboard = (event) => {\n      getBlobClipboard(event, blobClipboard => {\n        revokeStateURL();\n        this.setState({isImgClipboard: true, currPredictions: [], blobURL: []});\n        const imgObj = document.querySelector(\".face-image\");\n        imgObj.removeAttribute(\"onLoad\");   // remove the onLoad function temporarily bcz it will trigger send\n        if(blobClipboard){                  // if there's an image, display in canvas\n          this.setState({blobClipboard});   // stores the clipboard blob to state\n          document.querySelector('.face').classList.remove('hidden');   // reveal face component\n          imgObj.src = URL.createObjectURL(blobClipboard);    // Convert the blob into an ObjectURL and preview it\n        }\n      })\n    }\n\n    const {currPredictions, blobURL, userImages, userProfile} = this.state;\n    return (\n      <div className=\"App\">\n        <Nav onRouteChange={onRouteChange}/>\n        {\n          this.state.route === 'signin'\n          ? <Signin onRouteChange={onRouteChange} updateUser={updateUser} server={server} />\n            : this.state.route === 'register'\n              ? <Register onRouteChange={onRouteChange} updateUser={updateUser} server={server}/>\n              : <div className=\"main-content\">\n                  <Welcome userProfile={userProfile}/>\n                  <Search geturl={geturl} getState={getState} onDetect={onDetect} pasteClipboard={pasteClipboard}/>\n                  <Face currPredictions={currPredictions} blobURL={blobURL} setSendBlob={setSendBlob}/>\n                  <canvas id='myCanvas'></canvas>\n                  <Profile userImages={userImages} onClickProfileImg={onClickProfileImg} server={server}/>\n                </div>\n        }\n      </div>\n    )\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\nserviceWorker.unregister();\n"],"sourceRoot":""}